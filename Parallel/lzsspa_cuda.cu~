/**************************************************************
	LZSS.C -- A Data Compression Program
	(tab = 4 spaces)
***************************************************************
	4/6/1989 Haruhiko Okumura
	Use, distribute, and modify this program freely.
	Please send me your improved versions.
		PC-VAN		SCIENCE
		NIFTY-Serve	PAF01022
		CompuServe	74050,1022
**************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h> 
#include <time.h>
#include "helpers.cuh"

#define N		 4096	/* size of ring buffer */
#define F		   18	/* upper limit for match_length */
#define THRESHOLD	2   /* encode string into position and length
						   if match_length is greater than this */
#define NIL			N	/* index for root of binary search trees */

#define PARTITIONS 8

// TODO: need to remove coupling of all these variables


FILE	*infile, *outfile;  /* input & output files */

struct stat st; /* to get file size */
void createStringOfSize(int size, char * str_in[], char ** str_out[]){
	*str_in = (char *) malloc (size);
	int i;
	for(i=0; i<PARTITIONS; i++){
		*str_out[i] = (char *) malloc (size/PARTITIONS + size%PARTITIONS);
	}
}

// TODO: device
__device__ void InitTree(int lson[], int rson[], int dad[])  /* initialize trees */
{
	int  i;

	/* For i = 0 to N - 1, rson[i] and lson[i] will be the right and
	   left children of node i.  These nodes need not be initialized.
	   Also, dad[i] is the parent of node i.  These are initialized to
	   NIL (= N), which stands for 'not used.'
	   For i = 0 to 255, rson[N + i + 1] is the root of the tree
	   for strings that begin with character i.  These are initialized
	   to NIL.  Note there are 256 trees. */

	for (i = N + 1; i <= N + 256; i++) rson[i] = NIL;
	for (i = 0; i < N; i++) dad[i] = NIL;
}

// TODO: device
__device__ void InsertNode(int r, int lson[], int rson[], int dad[], int *match_position, int *match_length, unsigned char
		text_buf[]) 
	/* Inserts string of length F, text_buf[r..r+F-1], into one of the
	   trees (text_buf[r]'th tree) and returns the longest-match position
	   and length via the global variables match_position and match_length.
	   If match_length = F, then removes the old node in favor of the new
	   one, because the old one will be deleted sooner.
	   Note r plays double role, as tree node and position in buffer. */
{
	int  i, p, cmp;
	unsigned char  *key;

	cmp = 1;  key = &text_buf[r];  p = N + 1 + key[0];
	rson[r] = lson[r] = NIL;  *match_length = 0;
	for ( ; ; ) {
		if (cmp >= 0) {
			if (rson[p] != NIL) p = rson[p];
			else {  rson[p] = r;  dad[r] = p;  return;  }
		} else {
			if (lson[p] != NIL) p = lson[p];
			else {  lson[p] = r;  dad[r] = p;  return;  }
		}
		for (i = 1; i < F; i++)
			if ((cmp = key[i] - text_buf[p + i]) != 0)  break;
		if (i > *match_length) {
			*match_position = p;
			if ((*match_length = i) >= F)  break;
		}
	}
	dad[r] = dad[p];  lson[r] = lson[p];  rson[r] = rson[p];
	dad[lson[p]] = r;  dad[rson[p]] = r;
	if (rson[dad[p]] == p) rson[dad[p]] = r;
	else                   lson[dad[p]] = r;
	dad[p] = NIL;  /* remove p */
}

// TODO: device
__device__ void DeleteNode(int p, int lson[], int rson[], int dad[])  /* deletes node p from tree */
{
	int  q;
	
	if (dad[p] == NIL) return;  /* not in tree */
	if (rson[p] == NIL) q = lson[p];
	else if (lson[p] == NIL) q = rson[p];
	else {
		q = lson[p];
		if (rson[q] != NIL) {
			do {  q = rson[q];  } while (rson[q] != NIL);
			rson[dad[q]] = lson[q];  dad[lson[q]] = dad[q];
			lson[q] = lson[p];  dad[lson[p]] = q;
		}
		rson[q] = rson[p];  dad[rson[p]] = q;
	}
	dad[q] = dad[p];
	if (rson[dad[p]] == p) rson[dad[p]] = q;  else lson[dad[p]] = q;
	dad[p] = NIL;
}

// TODO: global
//                    
__global__ void Encode(int size, char * str_in, char * str_out, int *sizes)  //txt buf
{
	int  i, c, len, r, s, last_match_length, code_buf_ptr;
 
  	int part = threadIdx.x;  
  	int seeksize = size/PARTITIONS;
  	int upper = seeksize+(part==PARTITIONS ? size%PARTITIONS:0);
  	int offset = size/PARTITIONS * part;
	
	int match_position, match_length;  /* of longest match.  These are
			set by the InsertNode() procedure. */	
	int 	lson[N + 1], 
			rson[N + 257], 
			dad[N + 1];  /* left & right children &
				parents -- These constitute binary search trees. */
			
	unsigned char text_buf[N + F - 1];	/* ring buffer of size N,
			with extra F-1 bytes to facilitate string comparison */
			
	unsigned char  code_buf[17], mask;	
	
	unsigned long int
			textsize = 0,	/* text size counter */
			textcount = 0,	/* second text size counter */
			codesize = 0,	/* code size counter */
			printcount = 0;	/* counter for reporting progress every 1K bytes */
	
	InitTree(lson, rson, dad);  /* initialize trees */
	code_buf[0] = 0;  /* code_buf[1..16] saves eight units of code, and
		code_buf[0] works as eight flags, "1" representing that the unit
		is an unencoded letter (1 byte), "0" a position-and-length pair
		(2 bytes).  Thus, eight units require at most 16 bytes of code. */
	code_buf_ptr = mask = 1;
	s = 0;  r = N - F;
	for (i = s; i < r; i++) text_buf[i] = ' ';  /* Clear the buffer with
		any character that will appear often. */
	for (len = 0; len < F && (c = str_in[textcount+offset]) != EOF && ++textcount <= upper; len++)
		text_buf[r + len] = c;  /* Read F bytes into the last F bytes of
			the buffer */
	if ((textsize = len) == 0) {
		sizes[part] = 0;
		return;  /* text of size zero */
	}
	for (i = 1; i <= F; i++) InsertNode(r - i, lson, rson, dad, &match_position, &match_length, text_buf);  /* Insert the F strings,
		each of which begins with one or more 'space' characters.  Note
		the order in which these strings are inserted.  This way,
		degenerate trees will be less likely to occur. */
	InsertNode(r,lson, rson, dad, &match_position, &match_length, text_buf);  /* Finally, insert the whole string just read.  The
		global variables match_length and match_position are set. */
	do {
		if (match_length > len) match_length = len;  /* match_length
			may be spuriously long near the end of text. */
		if (match_length <= THRESHOLD) {
			match_length = 1;  /* Not long enough match.  Send one byte. */
			code_buf[0] |= mask;  /* 'send one byte' flag */
			code_buf[code_buf_ptr++] = text_buf[r];  /* Send uncoded. */
		} else {
			code_buf[code_buf_ptr++] = (unsigned char) match_position;
			code_buf[code_buf_ptr++] = (unsigned char)
				(((match_position >> 4) & 0xf0)
			  | (match_length - (THRESHOLD + 1)));  /* Send position and
					length pair. Note match_length > THRESHOLD. */
		}
		if ((mask <<= 1) == 0) {  /* Shift mask left one bit. */
			for (i = 0; i < code_buf_ptr; i++)  /* Send at most 8 units of */
				str_out[codesize+i+offset] = code_buf[i];     /* code together */
			codesize += code_buf_ptr;
			code_buf[0] = 0;  code_buf_ptr = mask = 1;
		}
		last_match_length = match_length;
		for (i = 0; i < last_match_length &&
				(c = str_in[textcount+offset]) != EOF && ++textcount <= upper; i++) {
			DeleteNode(s, lson, rson, dad);		/* Delete old strings and */
			text_buf[s] = c;	/* read new bytes */
			if (s < F - 1) text_buf[s + N] = c;  /* If the position is
				near the end of buffer, extend the buffer to make
				string comparison easier. */
			s = (s + 1) & (N - 1);  r = (r + 1) & (N - 1);
				/* Since this is a ring buffer, increment the position
				   modulo N. */
			InsertNode(r, lson, rson, dad, &match_position, &match_length, text_buf);	/* Register the string in text_buf[r..r+F-1] */
		}
		if ((textsize += i) > printcount) {
			/*printf("%12ld\r", textsize);*/  
			printcount += 1024; /* Reports progress each time the textsize exceeds
				   multiples of 1024. */
		}
		while (i++ < last_match_length) {	/* After the end of text, */
			DeleteNode(s, lson, rson, dad);					/* no need to read, but */
			s = (s + 1) & (N - 1);  r = (r + 1) & (N - 1);
			if (--len) InsertNode(r, lson, rson, dad, &match_position, &match_length, text_buf);		/* buffer may not be empty. */
		}
	} while (len > 0);	/* until length of string to be processed is zero */
	if (code_buf_ptr > 1) {		/* Send remaining code. */
		for (i = 0; i < code_buf_ptr; i++) str_out[codesize+i+offset] = code_buf[i];
		codesize += code_buf_ptr;
	}
	//printf("In : %ld bytes\n", textsize);	/* Encoding is done. */
	//printf("Out: %ld bytes\n", codesize);
	//printf("Out/In: %.3f\n", (double)codesize / textsize);
	sizes[part] = codesize;
}

// TODO: global
// no branches - no cuda for the moment
void Decode(FILE * in)	/* Just the reverse of Encode(). */
{
	int  i, j, k, r, c;
	unsigned int flags;
	
	unsigned char text_buf[N + F - 1];	/* ring buffer of size N,
			with extra F-1 bytes to facilitate string comparison */
	
	for (i = 0; i < N - F; i++) text_buf[i] = ' ';
	r = N - F;  flags = 0;
	for ( ; ; ) {
		if (((flags >>= 1) & 256) == 0) { 
			if ((c = getc(in)) == EOF) break;
			flags = c | 0xff00;		/* uses higher byte cleverly */
		}							/* to count eight */
		if (flags & 1) {
			if ((c = getc(in)) == EOF) break;
			putc(c, outfile);  text_buf[r++] = c;  r &= (N - 1);
		} else {
			if ((i = getc(in)) == EOF) break;
			if ((j = getc(in)) == EOF) break;
			i |= ((j & 0xf0) << 4);  j = (j & 0x0f) + THRESHOLD;
			for (k = 0; k <= j; k++) {
				c = text_buf[(i + k) & (N - 1)];
				putc(c, outfile);  text_buf[r++] = c;  r &= (N - 1);
			}
		}
	}
}

//cpu
void readFile(FILE * in, char * str_in){
	int i = 0;
	while(1){
		char c = getc(in);
		str_in[i++] = c;
		if(c == EOF) break;
	}
}

//cpu
void writeFile(FILE * out, int part, int sizes[], char * str_out[]){
	int i = 0;
	while(i < sizes[part]){
		putc(str_out[part][i++], out);
	}
	putc(EOF, out);
}


int main(int argc, char *argv[]) {
    char *s, *in;

    char * str_in; // TODO: can have in global memory since
    char * str_out; // TODO: need to come up with better way
    int sizes[PARTITIONS];

    if (argc != 4) {
        printf("'lzss e file1 file2' encodes file1 into file2.\n"
                "'lzss d file2 file1' decodes file2 into file1.\n");
        return EXIT_FAILURE;
    }
    if ((s = argv[1], s[1] || strpbrk(s, "DEde") == NULL)
            || (s = argv[2], in = argv[2], (infile = fopen(s, "rb")) == NULL)
            || (s = argv[3], (outfile = fopen(s, "wb")) == NULL)) {
        printf("??? %s\n", s);
        return EXIT_FAILURE;
    }
    remove(s);

    if (toupper(*argv[1]) == 'E') {
        /*
        time_t start = time(NULL);
        printf("\nStart time: %ld\n", start);
         */

        // file size
        stat(argv[2], &st);
        int size = st.st_size;
        //printf("%d\n",size);		

        str_in = (char *) malloc(size);

        //createStringOfSize(size, &str_in, &str_out);
        int i;
        str_out = (char *) malloc(size);

        readFile(infile, str_in);

        // TODO: move all to device memory;
        // device malloc > copy to card

        //cuda alloc
        char * str_in_cuda;
        char * str_out_cuda;
        int * sizes_cuda;

        //allocate gpu mem
        checkCuda(cudaMalloc((void**) &str_in_cuda, size));
        checkCuda(cudaMalloc((void**) &str_out_cuda, size));
        checkCuda(cudaMalloc((void**) &sizes_cuda, sizeof (int)*PARTITIONS));
        //int i;
        /*for (i = 0; i < PARTITIONS; i++) {
            
            //cudaMalloc((void**) &str_out_cuda[i], (size / PARTITIONS + size % PARTITIONS) * sizeof (char));
            checkCuda(cudaMalloc((void**) &str_out_cuda[i], (size / PARTITIONS + size % PARTITIONS) * sizeof (char)));
        }*/

        //copy to cuda mem
        //cudaMemcpy(str_in_cuda, str_in, size, cudaMemcpyHostToDevice);
        checkCuda(cudaMemcpy(str_in_cuda, str_in, size, cudaMemcpyHostToDevice));

        // TODO: kernel call - save all encoded files to array elements
        // run function on GPU <<<blocks, no_of_threads>>>

        Encode << < 1, PARTITIONS >>>(size, str_in_cuda, str_out_cuda, sizes_cuda);

        // TODO: copy back to RAM from GPU
        //cudaMemcpy(str_out, str_out_cuda, PARTITIONS * sizeof (char*), cudaMemcpyDeviceToHost);
        //TODO: :cudaErrorInvalidValue Error Code : 11
        //checkCuda(cudaMemcpy(str_out, str_out_cuda, PARTITIONS * sizeof(char*), cudaMemcpyDeviceToHost));

        for (i = 0; i < PARTITIONS; i++) {
            //cudaMemcpy(str_out, str_out_cuda, (size / PARTITIONS + size % PARTITIONS) * sizeof (char), cudaMemcpyDeviceToHost);
            checkCuda(cudaMemcpy(str_out, str_out_cuda, (size/PARTITIONS + size%PARTITIONS)*sizeof(char), cudaMemcpyDeviceToHost));
        }
        cudaMemcpy(sizes, sizes_cuda, sizeof (int)*PARTITIONS, cudaMemcpyDeviceToHost);
        //checkCuda(cudaMemcpy(sizes, sizes_cuda, sizeof(int)*PARTITIONS, cudaMemcpyDeviceToHost));

        // TODO: file write
        for (i = 0; i < PARTITIONS; i++) {
            printf("part %d - %d\n", i, sizes[i]);
            // file names
            sprintf(s, "%s.%d", s, i);
            FILE * out = fopen(s, "wb");
            s[strlen(s) - 2] = '\0';

            // write encoded
            //writeFile(out, i, sizes, str_out);
        }

        /*
        // fork
        pid_t pids[PARTITIONS];
        for(part = 0; part < PARTITIONS; part++){
        	int pid =fork();
        	if(pid > 0) {
            	pids[part] = pid;
            	continue;
        	} else {        
            	//Encode(seeksize+(part==PARTITIONS ? size%PARTITIONS:0), part, size/PARTITIONS * part, str_in, str_out, sizes);        
        
        		// file names
                                sprintf(s,"%s.%d",s,part);
                                FILE * out = fopen(s, "wb");
                                s[strlen(s)-2] = '\0';
        
        // write encoded
                                writeFile(out, part, sizes, str_out);
                                return EXIT_SUCCESS;
                        }
                }
                for(part = 0; part < PARTITIONS; part++) {
                        if(pids[part] > 0) {
                                printf("\n\nWaiting on part: %d\n\n", part);
                                waitpid(pids[part], NULL, 0);
                        }
                }*/

        /*
                     time_t end = time(NULL);// - start;
                     printf("\nEnd time: %ld\n", end);
                     printf("\nTime taken: %f\n",difftime(end, start));
		*/
    } else {
        // Decode
        int part = 0;
        for (part = 0; part < PARTITIONS; part++) {
            in[strlen(in) - 2] = '\0';
            sprintf(in, "%s.%d", in, part);
            printf("%s\n", in);
            FILE * inf = fopen(in, "rb");
            Decode(inf);
            fclose(inf);
        }
    }
    fclose(infile);
    fclose(outfile);
    return EXIT_SUCCESS;
}
